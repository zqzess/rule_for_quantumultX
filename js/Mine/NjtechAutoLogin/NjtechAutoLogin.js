/*
ã€å—äº¬å·¥ä¸šå¤§å­¦æ ¡å›­ç½‘è‡ªåŠ¨ç™»å½•ã€‘@zqzess
ã€ä»“åº“åœ°å€ã€‘https://github.com/zqzess/rule_for_quantumultXï¼ˆæ¬¢è¿ŽstarðŸŒŸï¼‰
ã€ä»“åº“åœ°å€ã€‘https://github.com/zqzess/Njtech-AutoLoginï¼ˆæ¬¢è¿ŽstarðŸŒŸï¼‰
ã€BoxJsã€‘https://raw.githubusercontent.com/zqzess/rule_for_quantumultX/master/js/Mine/boxjs.json
ã€æ›´æ–°æ—¶é—´ã€‘2022-7-1
ã€è‡´è°¢ã€‘
æ„Ÿè°¢Peng-YMçš„OpenAPI.jsï¼
âš ï¸ã€å…è´£å£°æ˜Žã€‘
------------------------------------------
1ã€æ­¤è„šæœ¬ä»…ç”¨äºŽå­¦ä¹ ç ”ç©¶ï¼Œä¸ä¿è¯å…¶åˆæ³•æ€§ã€å‡†ç¡®æ€§ã€æœ‰æ•ˆæ€§ï¼Œè¯·æ ¹æ®æƒ…å†µè‡ªè¡Œåˆ¤æ–­ï¼Œæœ¬äººå¯¹æ­¤ä¸æ‰¿æ‹…ä»»ä½•ä¿è¯è´£ä»»ã€‚
2ã€ç”±äºŽæ­¤è„šæœ¬ä»…ç”¨äºŽå­¦ä¹ ç ”ç©¶ï¼Œæ‚¨å¿…é¡»åœ¨ä¸‹è½½åŽ 24 å°æ—¶å†…å°†æ‰€æœ‰å†…å®¹ä»Žæ‚¨çš„è®¡ç®—æœºæˆ–æ‰‹æœºæˆ–ä»»ä½•å­˜å‚¨è®¾å¤‡ä¸­å®Œå…¨åˆ é™¤ï¼Œè‹¥è¿åè§„å®šå¼•èµ·ä»»ä½•äº‹ä»¶æœ¬äººå¯¹æ­¤å‡ä¸è´Ÿè´£ã€‚
3ã€è¯·å‹¿å°†æ­¤è„šæœ¬ç”¨äºŽä»»ä½•å•†ä¸šæˆ–éžæ³•ç›®çš„ï¼Œè‹¥è¿åè§„å®šè¯·è‡ªè¡Œå¯¹æ­¤è´Ÿè´£ã€‚
4ã€æ­¤è„šæœ¬æ¶‰åŠåº”ç”¨ä¸Žæœ¬äººæ— å…³ï¼Œæœ¬äººå¯¹å› æ­¤å¼•èµ·çš„ä»»ä½•éšç§æ³„æ¼æˆ–å…¶ä»–åŽæžœä¸æ‰¿æ‹…ä»»ä½•è´£ä»»ã€‚
5ã€æœ¬äººå¯¹ä»»ä½•è„šæœ¬å¼•å‘çš„é—®é¢˜æ¦‚ä¸è´Ÿè´£ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºŽç”±è„šæœ¬é”™è¯¯å¼•èµ·çš„ä»»ä½•æŸå¤±å’ŒæŸå®³ã€‚
6ã€å¦‚æžœä»»ä½•å•ä½æˆ–ä¸ªäººè®¤ä¸ºæ­¤è„šæœ¬å¯èƒ½æ¶‰å«Œä¾µçŠ¯å…¶æƒåˆ©ï¼Œåº”åŠæ—¶é€šçŸ¥å¹¶æä¾›èº«ä»½è¯æ˜Žï¼Œæ‰€æœ‰æƒè¯æ˜Žï¼Œæˆ‘ä»¬å°†åœ¨æ”¶åˆ°è®¤è¯æ–‡ä»¶ç¡®è®¤åŽåˆ é™¤æ­¤è„šæœ¬ã€‚
7ã€æ‰€æœ‰ç›´æŽ¥æˆ–é—´æŽ¥ä½¿ç”¨ã€æŸ¥çœ‹æ­¤è„šæœ¬çš„äººå‡åº”è¯¥ä»”ç»†é˜…è¯»æ­¤å£°æ˜Žã€‚æœ¬äººä¿ç•™éšæ—¶æ›´æ”¹æˆ–è¡¥å……æ­¤å£°æ˜Žçš„æƒåˆ©ã€‚ä¸€æ—¦æ‚¨ä½¿ç”¨æˆ–å¤åˆ¶äº†æ­¤è„šæœ¬ï¼Œå³è§†ä¸ºæ‚¨å·²æŽ¥å—æ­¤å…è´£å£°æ˜Žã€‚
ã€ä½¿ç”¨è¯´æ˜Žã€‘
å—äº¬å·¥ä¸šå¤§å­¦å®¿èˆç½‘ Njtech-Home æ— çº¿ç½‘è‡ªåŠ¨ç™»å½•

ã€Surgeã€‘
-----------------

ä¸¤ç§ä½¿ç”¨æ–¹æ³•
- å¯ä»¥åœ¨å°†è„šæœ¬å†…å®¹å¤åˆ¶ï¼Œåœ¨æœ¬åœ°æ–°å»ºè„šæœ¬ï¼Œç±»åž‹é€‰æ‹©eventæˆ–cronï¼Œç„¶åŽç¦ç”¨ï¼Œiosæ·å¾„æ–°å¢žè‡ªåŠ¨åŒ–ï¼Œé€‰æ‹©å½“åŠ å…¥Njetch-Home Wi-Fiæ—¶ æ‰§è¡Œsurgè„šæœ¬ï¼Œå¡«å…¥è„šæœ¬åç§°ï¼Œå®Œæˆã€‚**ç¼ºç‚¹ï¼šæ­¤æ·å¾„ä¼šå¼¹å‡ºé€šçŸ¥ï¼Œéœ€è¦æ‰‹åŠ¨ç‚¹å‡»è¿è¡Œ**
- æœ¬åœ°æ·»åŠ è„šæœ¬(eventç±»åž‹ï¼Œè§¦å‘äº‹ä»¶æ˜¯network-changed)æˆ–è€…å®‰è£…æ¨¡å—ï¼Œæ¯ä¸€æ¬¡ç½‘ç»œæ”¹å˜éƒ½ä¼šè§¦å‘è„šæœ¬ï¼Œè„šæœ¬å†…ç½®Wi-Fi ssidè¯†åˆ«,æ˜¯Njtech-Homeæ—¶ä¼šæ‰§è¡Œç™»å½•ï¼Œå…¶ä»–å¿½ç•¥

**æœ¬åœ°æ–°å»ºçš„è„šæœ¬ï¼Œå¯ä»¥ä¹‹é—´æŠŠè´¦æˆ·å¯†ç å¡«å†™åœ¨è„šæœ¬å†…**

**æ¨¡å—å®‰è£…çš„è„šæœ¬éœ€è¦å€ŸåŠ©boxjså¡«å†™æˆ–è€…åœ¨surge $persistentStoreå†…æ·»åŠ å­—æ®µ**
- > $persistentStore æ·»åŠ å­—æ®µnjtechAutoLogin,å¡«å…¥ {"njtech_id":"å­¦å·","njtech_pwd":"å¯†ç ","njtech_option":"@telecom"}
- > [BoxJsè¯´æ˜Žæ–‡æ¡£](https://github.com/chavyleung/boxjs-doc)
- > [BoxJsæ¨¡å—](https://raw.githubusercontent.com/chavyleung/scripts/master/box/rewrite/boxjs.rewrite.surge.sgmodule)
- > boxjsæ¨¡å—å¼€å¯åŽè®¿é—®`http://boxjs.com`,æ·»åŠ ä¸‹é¢çš„é“¾æŽ¥è®¢é˜…boxjsåº”ç”¨
- > [boxjså†…è®¢é˜…](https://raw.githubusercontent.com/zqzess/rule_for_quantumultX/master/js/Mine/boxjs.json)

[Script]
NjetchAutologin = type=event,script-path=https://raw.githubusercontent.com/zqzess/rule_for_quantumultX/master/js/Mine/NjtechAutoLogin/NjtechAutoLogin.js,event-name=network-changed,timeout=6

########################

ã€Quantumult Xã€‘
-----------------

éœ€è¦é…åˆæ·å¾„ä½¿ç”¨ï¼Œæ·å¾„æ–°å¢žè‡ªåŠ¨åŒ–ï¼Œé€‰æ‹©æ— çº¿å±€åŸŸç½‘ï¼Œé€‰å–Njtech-Homeï¼Œä¸‹ä¸€æ­¥æœç´¢Quantumult Xï¼Œè¿è¡Œjsè„šæœ¬ï¼Œå¡«å…¥è„šæœ¬è·¯å¾„(å­˜åœ¨æœ¬åœ°çš„è„šæœ¬å¡«å…¥NjtechAutoLogin.jså³å¯)

QuantumultXçš„å¥½å¤„å°±æ˜¯å¯ä»¥ä¸ç”¨å¯åŠ¨QuantumultXå°±å¯ä»¥è¿è¡Œè„šæœ¬ï¼Œä½†æ˜¯åŒæ ·ï¼Œæ·å¾„ä¼šå¼¹çª—éœ€è¦æ‰‹åŠ¨ç‚¹å‡»è¿è¡Œ

**æœ¬åœ°å­˜æ”¾è„šæœ¬çš„å¯ä»¥æŠŠå­¦å·å¯†ç å†™æ­»è„šæœ¬å†…ï¼Œè¿œç¨‹çš„éœ€è¦è®¢é˜…boxjsé…ç½®æ–‡ä»¶å¡«å†™è´¦æˆ·å¯†ç **

- > [BoxJsè¯´æ˜Žæ–‡æ¡£](https://github.com/chavyleung/boxjs-doc)
- > [BoxJsé‡å†™è®¢é˜…](https://raw.githubusercontent.com/chavyleung/scripts/master/box/rewrite/boxjs.rewrite.quanx.conf)
- > boxjsæ¨¡å—å¼€å¯åŽè®¿é—®`http://boxjs.com`,æ·»åŠ ä¸‹é¢çš„é“¾æŽ¥è®¢é˜…boxjsåº”ç”¨
- > [boxjså†…è®¢é˜…](https://raw.githubusercontent.com/zqzess/rule_for_quantumultX/master/js/Mine/boxjs.json)


QuantumultXé…ç½®æ–‡ä»¶`[task_local]`   æ·»åŠ ä»¥ä¸‹é“¾æŽ¥

[task_local]
0 7 * * * https://raw.githubusercontent.com/zqzess/rule_for_quantumultX/master/js/Mine/NjtechAutoLogin/NjtechAutoLogin.js, tag=å—äº¬å·¥ä¸šå¤§å­¦æ ¡å›­ç½‘è‡ªåŠ¨ç™»å½•

##########################

ã€NodeJsã€‘
-----------------

éœ€è¦æŠŠè„šæœ¬å†…
```
$.userid = $.read("njtech_id");
$.userpwd = $.read("njtech_pwd");
$.optionitem = $.read("njtech_option");
```
æ”¹ä¸º
```
$.userid = 'å­¦å·';
$.userpwd = 'å¯†ç ';
$.optionitem = '@telecom';
```
*/
const $ = new API("njtechAutoLogin", false);

$.userid = $.read("njtech_id");
$.userpwd = $.read("njtech_pwd");
$.optionitem = $.read("njtech_option");
$.wifi2 = $.read("njtech_wifi2");

// $.userid = 'å­¦å·';
// $.userpwd = 'å¯†ç ';
// $.optionitem = '@telecom';  //ä¸­å›½ç”µä¿¡å¡«å†™ @telecom ï¼Œä¸­å›½ç§»åŠ¨å¡«å†™ @cmcc

let flag = $.userid !== "" && $.userid !== null && $.userid !== undefined && $.userpwd !== "" && $.userpwd !== null && $.userpwd !== undefined && $.optionitem !== "" && $.optionitem !== null && $.optionitem !== undefined;


const getAddr = 'https://u.njtech.edu.cn/cas/login?service=https://u.njtech.edu.cn/oauth2/authorize?client_id=Oe7wtp9CAMW0FVygUasZ&response_type=code&state=njtech'
const postAddr = 'https://u.njtech.edu.cn/cas/login?service=https%3A%2F%2Fu.njtech.edu.cn%2Foauth2%2Fauthorize%3Fclient_id%3DOe7wtp9CAMW0FVygUasZ%26response_type%3Dcode%26state%3Dnjtech%26s%3Df682b396da8eb53db80bb072f5745232'
const headers = {
    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 15_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Mobile/15E148 Safari/604.1',
    'Accept': '*/*',
    'Accept-Language': 'zh-CN,zh;q=0.9',
    'Content-Type': 'application/x-www-form-urlencoded',
    'Connection': 'keep-alive',
};

const {isQX, isLoon, isSurge, isScriptable, isNode} = ENV();
let loginInfo = {};
let notifyTitle = "Njtech-Home"

!(async () => {
    let isStart = false;
    if (isSurge) {
        const network = $network.wifi.ssid;
        $.info(network);
        if (network === 'Njtech-Home') {
            isStart = true;
        }
        if ($.wifi2 !== "" && $.wifi2 !== null && $.wifi2 !== undefined) {
            if (network === $.wifi2) {
                isStart = true;
                notifyTitle = $.wifi2;
            }
        }
    }
    if (isStart) {
        if (flag) {
            await getLoginInfo();
            await startLogin();
        } else
            $.notify(notifyTitle, "", "âŒ è¯·å…ˆå¡«å†™ç™»å½•ä¿¡æ¯");
    }
})()
    .catch((err) => {
        $.error(err);
    })
    .finally(() => $.done());


function getLoginInfo() {
    if (isSurge || isQX)
        headers['Cookie'] = 'JSESSIONID=6E065A716A506E060241DBBBE7A60C6E.TomcatB;';
    $.log(headers)
    return $.http.get({
        url: getAddr,
        headers
    }).then(resp => {
        const headers = resp.headers;
        $.log(headers);
        let cookie1 = ''
        let cookie2 = ''
        let cookie = ''
        if (isNode) {
            cookie1 = headers["set-cookie"][0];
            cookie1 = cookie1.replace(' Path=/cas; HttpOnly', '');
            cookie2 = headers["set-cookie"][1];
            cookie2 = cookie2.replace('; path=/', '');
            cookie = cookie1 + ' ' + cookie2;
        } else if (isSurge || isQX) {
            cookie1 = headers["Set-Cookie"];
            cookie1 = cookie1.replace(' Path=/cas; HttpOnly,', '');
            cookie = cookie1.replace('; path=/', '');
        }
        $.log(cookie);
        let obj = resp.body;
        // let tmp = obj.match('input type="hidden" name="lt" value=\".+\" \/> <input');
        let lt_new = obj.match(/input type="hidden" name="lt" value=\"(\S*)\" \/>/)[1];
        $.log(lt_new);
        let execution_new = obj.match(/type="hidden" name="execution" value=\"(\S*)\" \/>/)[1];
        $.log(execution_new);
        loginInfo = {"cookie": cookie, "lt": lt_new, "execution": execution_new};
    })
}

function startLogin() {
    $.info(loginInfo);
    $.log("è‡ªåŠ¨ç™»å½•æ•°æ®å¡«å……")
    let optionitem = 'ä¸­å›½ç”µä¿¡';
    if ($.optionitem === '@cmcc')
        optionitem = 'ä¸­å›½ç§»åŠ¨';
    else if ($.optionitem === 'default')
        optionitem = 'æ ¡å›­å†…ç½‘';
    let post_data = '';   //æœ€ç»ˆè¦æäº¤çš„æ•°æ®
    let pre_data = `username=${$.userid}&password=${$.userpwd}&channelshow=${optionitem}&channel=${$.optionitem}&lt=${loginInfo["lt"]}&execution=${loginInfo["execution"]}&_eventId=submit&submit=ç™»å½•`
    let pre_data2 = {
        "username": $.userid,
        "password": $.userpwd,
        "channelshow": optionitem,
        "channel": $.optionitem,
        "lt": loginInfo["lt"],
        "execution": loginInfo["execution"],
        "_eventId": "submit",
        "submit": "ç™»å½•"
    }
    headers['Cookie'] = loginInfo["cookie"];
    if (isNode)
        post_data = pre_data;
    if (isSurge || isQX)
        post_data = pre_data;
    $.info(post_data);
    $.info(headers);
    return $.http.post({
        url: postAddr,
        body: post_data,
        headers: headers,
    }).then(async resp => {
        if (isNode) {
            if (resp.statusCode === 302) {
                await $.http.get({
                    url: "https://www.baidu.com",
                    timeout: 5000,
                    headers,
                    events: {
                        onTimeout: () => {
                            $.error("ç™»å½•å¤±è´¥")
                            $.notify(
                                notifyTitle,
                                "âŒ ç™»å½•å¤±è´¥",
                                "è¯·å°è¯•æ‰‹åŠ¨ç™»å½•ï¼"
                            );
                        }
                    }
                }).then(resp => {
                    if (resp.statusCode === 200)
                        $.notify(
                            notifyTitle,
                            "âœ…ï¸ æˆåŠŸ",
                            "è‡ªåŠ¨ç™»å½•æˆåŠŸï¼"
                        );
                }).catch((error) => {
                    $.log(error);
                });
            } else {
                $.notify(
                    notifyTitle,
                    "âŒ ç™»å½•å¤±è´¥",
                    "è¯·å°è¯•æ‰‹åŠ¨ç™»å½•ï¼"
                );
            }
        } else {
            if (resp.statusCode === 200) {
                await $.http.get({
                    url: "https://www.baidu.com",
                    headers
                }).then(resp => {
                    if (resp.statusCode === 200) {
                        $.notify(
                            notifyTitle,
                            "âœ…ï¸ æˆåŠŸ",
                            "è‡ªåŠ¨ç™»å½•æˆåŠŸï¼"
                        );
                    } else {
                        $.notify(
                            notifyTitle,
                            "âŒ ç™»å½•å¤±è´¥",
                            "è¯·å°è¯•æ‰‹åŠ¨ç™»å½•ï¼"
                        );
                    }
                }).catch((error) => {
                    $.log(error);
                });
            }
        }
    })
}

/**
 * OpenAPI
 * @author: Peng-YM
 * https://github.com/Peng-YM/QuanX/blob/master/Tools/OpenAPI/README.md
 */
function ENV() {
    const isQX = typeof $task !== "undefined";
    const isLoon = typeof $loon !== "undefined";
    const isSurge = typeof $httpClient !== "undefined" && !isLoon;
    const isJSBox = typeof require == "function" && typeof $jsbox != "undefined";
    const isNode = typeof require == "function" && !isJSBox;
    const isRequest = typeof $request !== "undefined";
    const isScriptable = typeof importModule !== "undefined";
    return {
        isQX,
        isLoon,
        isSurge,
        isNode,
        isJSBox,
        isRequest,
        isScriptable,
    };
}

function HTTP(
    defaultOptions = {
        baseURL: "",
    }
) {
    const {isQX, isLoon, isSurge, isScriptable, isNode} = ENV();
    const methods = ["GET", "POST", "PUT", "DELETE", "HEAD", "OPTIONS", "PATCH"];
    const URL_REGEX =
        /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/;

    function send(method, options) {
        options =
            typeof options === "string"
                ? {
                    url: options,
                }
                : options;
        const baseURL = defaultOptions.baseURL;
        if (baseURL && !URL_REGEX.test(options.url || "")) {
            options.url = baseURL ? baseURL + options.url : options.url;
        }
        if (options.body && options.headers && !options.headers["Content-Type"]) {
            options.headers["Content-Type"] = "application/x-www-form-urlencoded";
        }
        options = {
            ...defaultOptions,
            ...options,
        };
        const timeout = options.timeout;
        const events = {
            ...{
                onRequest: () => {
                },
                onResponse: (resp) => resp,
                onTimeout: () => {
                },
            },
            ...options.events,
        };

        events.onRequest(method, options);

        let worker;
        if (isQX) {
            worker = $task.fetch({
                method,
                ...options,
            });
        } else if (isLoon || isSurge || isNode) {
            worker = new Promise((resolve, reject) => {
                const request = isNode ? require("request") : $httpClient;
                request[method.toLowerCase()](options, (err, response, body) => {
                    if (err) reject(err);
                    else
                        resolve({
                            statusCode: response.status || response.statusCode,
                            headers: response.headers,
                            body,
                        });
                });
            });
        } else if (isScriptable) {
            const request = new Request(options.url);
            request.method = method;
            request.headers = options.headers;
            request.body = options.body;
            worker = new Promise((resolve, reject) => {
                request
                    .loadString()
                    .then((body) => {
                        resolve({
                            statusCode: request.response.statusCode,
                            headers: request.response.headers,
                            body,
                        });
                    })
                    .catch((err) => reject(err));
            });
        }

        let timeoutid;
        const timer = timeout
            ? new Promise((_, reject) => {
                timeoutid = setTimeout(() => {
                    events.onTimeout();
                    return reject(
                        `${method} URL: ${options.url} exceeds the timeout ${timeout} ms`
                    );
                }, timeout);
            })
            : null;

        return (
            timer
                ? Promise.race([timer, worker]).then((res) => {
                    clearTimeout(timeoutid);
                    return res;
                })
                : worker
        ).then((resp) => events.onResponse(resp));
    }

    const http = {};
    methods.forEach(
        (method) =>
            (http[method.toLowerCase()] = (options) => send(method, options))
    );
    return http;
}

function API(name = "untitled", debug = false) {
    const {isQX, isLoon, isSurge, isNode, isJSBox, isScriptable} = ENV();
    return new (class {
        constructor(name, debug) {
            this.name = name;
            this.debug = debug;

            this.http = HTTP();
            this.env = ENV();

            this.node = (() => {
                if (isNode) {
                    const fs = require("fs");

                    return {
                        fs,
                    };
                } else {
                    return null;
                }
            })();
            this.initCache();

            const delay = (t, v) =>
                new Promise(function (resolve) {
                    setTimeout(resolve.bind(null, v), t);
                });

            Promise.prototype.delay = function (t) {
                return this.then(function (v) {
                    return delay(t, v);
                });
            };
        }

        // persistence
        // initialize cache
        initCache() {
            if (isQX) this.cache = JSON.parse($prefs.valueForKey(this.name) || "{}");
            if (isLoon || isSurge)
                this.cache = JSON.parse($persistentStore.read(this.name) || "{}");

            if (isNode) {
                // create a json for root cache
                let fpath = "root.json";
                if (!this.node.fs.existsSync(fpath)) {
                    this.node.fs.writeFileSync(
                        fpath,
                        JSON.stringify({}),
                        {
                            flag: "wx",
                        },
                        (err) => console.log(err)
                    );
                }
                this.root = {};

                // create a json file with the given name if not exists
                fpath = `${this.name}.json`;
                if (!this.node.fs.existsSync(fpath)) {
                    this.node.fs.writeFileSync(
                        fpath,
                        JSON.stringify({}),
                        {
                            flag: "wx",
                        },
                        (err) => console.log(err)
                    );
                    this.cache = {};
                } else {
                    this.cache = JSON.parse(
                        this.node.fs.readFileSync(`${this.name}.json`)
                    );
                }
            }
        }

        // store cache
        persistCache() {
            const data = JSON.stringify(this.cache, null, 2);
            if (isQX) $prefs.setValueForKey(data, this.name);
            if (isLoon || isSurge) $persistentStore.write(data, this.name);
            if (isNode) {
                this.node.fs.writeFileSync(
                    `${this.name}.json`,
                    data,
                    {
                        flag: "w",
                    },
                    (err) => console.log(err)
                );
                this.node.fs.writeFileSync(
                    "root.json",
                    JSON.stringify(this.root, null, 2),
                    {
                        flag: "w",
                    },
                    (err) => console.log(err)
                );
            }
        }

        write(data, key) {
            this.log(`SET ${key}`);
            if (key.indexOf("#") !== -1) {
                key = key.substr(1);
                if (isSurge || isLoon) {
                    return $persistentStore.write(data, key);
                }
                if (isQX) {
                    return $prefs.setValueForKey(data, key);
                }
                if (isNode) {
                    this.root[key] = data;
                }
            } else {
                this.cache[key] = data;
            }
            this.persistCache();
        }

        read(key) {
            this.log(`READ ${key}`);
            if (key.indexOf("#") !== -1) {
                key = key.substr(1);
                if (isSurge || isLoon) {
                    return $persistentStore.read(key);
                }
                if (isQX) {
                    return $prefs.valueForKey(key);
                }
                if (isNode) {
                    return this.root[key];
                }
            } else {
                return this.cache[key];
            }
        }

        delete(key) {
            this.log(`DELETE ${key}`);
            if (key.indexOf("#") !== -1) {
                key = key.substr(1);
                if (isSurge || isLoon) {
                    return $persistentStore.write(null, key);
                }
                if (isQX) {
                    return $prefs.removeValueForKey(key);
                }
                if (isNode) {
                    delete this.root[key];
                }
            } else {
                delete this.cache[key];
            }
            this.persistCache();
        }

        // notification
        notify(title, subtitle = "", content = "", options = {}) {
            const openURL = options["open-url"];
            const mediaURL = options["media-url"];

            if (isQX) $notify(title, subtitle, content, options);
            if (isSurge) {
                $notification.post(
                    title,
                    subtitle,
                    content + `${mediaURL ? "\nå¤šåª’ä½“:" + mediaURL : ""}`,
                    {
                        url: openURL,
                    }
                );
            }
            if (isLoon) {
                let opts = {};
                if (openURL) opts["openUrl"] = openURL;
                if (mediaURL) opts["mediaUrl"] = mediaURL;
                if (JSON.stringify(opts) === "{}") {
                    $notification.post(title, subtitle, content);
                } else {
                    $notification.post(title, subtitle, content, opts);
                }
            }
            if (isNode || isScriptable) {
                const content_ =
                    content +
                    (openURL ? `\nç‚¹å‡»è·³è½¬: ${openURL}` : "") +
                    (mediaURL ? `\nå¤šåª’ä½“: ${mediaURL}` : "");
                if (isJSBox) {
                    const push = require("push");
                    push.schedule({
                        title: title,
                        body: (subtitle ? subtitle + "\n" : "") + content_,
                    });
                } else {
                    console.log(`${title}\n${subtitle}\n${content_}\n\n`);
                }
            }
        }

        // other helper functions
        log(msg) {
            if (this.debug) console.log(`[${this.name}] LOG: ${this.stringify(msg)}`);
        }

        info(msg) {
            console.log(`[${this.name}] INFO: ${this.stringify(msg)}`);
        }

        error(msg) {
            console.log(`[${this.name}] ERROR: ${this.stringify(msg)}`);
        }

        wait(millisec) {
            return new Promise((resolve) => setTimeout(resolve, millisec));
        }

        done(value = {}) {
            if (isQX || isLoon || isSurge) {
                $done(value);
            } else if (isNode && !isJSBox) {
                if (typeof $context !== "undefined") {
                    $context.headers = value.headers;
                    $context.statusCode = value.statusCode;
                    $context.body = value.body;
                }
            }
        }

        stringify(obj_or_str) {
            if (typeof obj_or_str === "string" || obj_or_str instanceof String)
                return obj_or_str;
            else
                try {
                    return JSON.stringify(obj_or_str, null, 2);
                } catch (err) {
                    return "[object Object]";
                }
        }
    })(name, debug);
}
